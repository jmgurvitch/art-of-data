---
layout: post
title: Lab 2 - Animal Crossing
subtitle: Expanding my coding horizons...reaching New Horizons, if you will.
cover-img: assets/img/animal-crossing-masthead.jpg
gh-repo: jmgurvitch/art-of-data
tags: [labs]
comments: true
---

Hello there! Lab 2 (the Animal Crossing lab) is an exercise in using APIs and Python classes to read and write data. I generated a csv file that I then analyzed with Python to answer the lab's questions.

## Making the dataset

When making the dataset, I initially thought that I would be best served by creating a class `Sock`, which was fairly straightforward. I soon discovered, however, that having such a class made the rest of the lab far less straightforward; anything that I could do with the class I could do with less code without it. Additionally, the data retrieved from the API was already in a form that could be easily inputted into a csv, so there was no reason to process it a bunch. I therefore did away with the class and focused on recreating the entire Animal Crossing spreadsheet in a csv that I could use for subsequent questions.

Here's the whole function, where `BASE_URL = "http://hm-cs.herokuapp.com"`, `ENDPOINT = "/socks"`, and `API_KEY = "ArtOfDataKEY123"`:
```py
def make_csv(): #query the API for data and use that data to generate a CSV with relevant information
    with open("socks.csv", "w") as socks_csv:

        payload = {"key": API_KEY, "idx": 0} #variable index for iteration-capable payload
        response = requests.get(BASE_URL + ENDPOINT, params = payload)

        #iterate through the API's indices until we pass the maximum allowable index, at which we will receive an error code
        while response.ok:
            if payload["idx"] == 0:
                response_text = response.text[1:] #cut off first letter from only the first row
            else:
                response_text = response.text

            socks_csv.write(response_text + "\n") #every response comprises a new row in socks_csv
            payload["idx"] += 1 #increase index by one to access the next entry in the API data
            response = requests.get(BASE_URL + ENDPOINT, params = payload) #update response

```
This produces socks.csv, a csv of all of the data retrieved from the API.

## Question 1
**Which sock has the most variations? If there is more than one answer, then list all of them.**

Having just finished a practice lab on nested dictionaries (the penguins one), I began the lab with the expectation that nested dictionaries would be central to every question. I thus tried to approach question 1 with nested dictionaries, which is a viable strategy. However, as I thought more about the question I realized that it could be solved much more simply (Occam's razor strikes again) by iterating through the dataset, summing the Digimon's speeds, and dividing that sum by the number of Digimon in the dataset to find the average speed. 

Here's the whole function:
```py
def max_sock_variations():
    
    sock_variations_dict = {} #dictionary to store sock variations and their counts

    with open("socks.csv", "r") as socks_csv:
        
        data = csv.DictReader(socks_csv)
            
        #iterate through the "Name" column of socks.csv and count the number of instances--variations--of each sock type
        for row in data:
            if row["Name"] not in sock_variations_dict.keys(): #if new sock type
                sock_variations_dict[row["Name"]] = 1

            else: #if we've seen the sock type before
                sock_variations_dict[row["Name"]] += 1 #add one to count of that sock type
    
    #find highest number of variations by casting sock_variations_dict to a list
    max_variations = max(list(sock_variations_dict.values()))

    #make a list in which we will store all socks that have the max # of variations
    max_variations_list = []

    #iterate through each key-value pair. if a pair's value equals the max # of variations, then print its corresponding key
    for k, v in sock_variations_dict.items():
        if v == max_variations:
            max_variations_list.append(k)

    print("The following sock types have the maximum number of variations, which is " + str(max_variations) + " variations: " + str(max_variations_list))
```
This returns the following: 

`The following sock types have the maximum number of variations, which is 8 variations: ['argyle crew socks', 'color-blocked socks', 'frilly knee-high socks', 'holey tights', 'kiddie socks', 'mixed-tweed socks', 'no-show socks', 'semi-opaque socks', 'semi-opaque tights', 'sequin leggings', 'simple-accent socks', 'striped socks', 'striped tights', 'tube socks', 'ultra no-show socks', 'vivid leggings', 'vivid socks', 'vivid tights']`

## Question 2
**How many socks of each color are there? If a sock has two _different_ colors, it should be counted in both. _However_, if a sock has the same Color1 and Color2, make sure you donâ€™t double count it!**



Having dispelled my tunnel vision on nested dictionaries over the course of my completing question 1, I approached this question without any such expectation. Consequently, the solution came to me fairly quickly. I used a for loop to iterate through all Digimon and add one to a counter if the Digimon at hand satisfied the desired attribute, which was a string or int in a specified column of the Digimon dataset.

Here's the whole function:
```py
def num_sock_colors():
    
    sock_colors_dict = {} #dictionary to record sock colors and their counts
    
    with open("socks.csv", "r") as socks_csv:

        data = csv.DictReader(socks_csv)

        #iterate through the "Color 1" column and then the "Color 2" column of socks.csv and count the number of instances--variations--of each sock type
        for row in data:
            #color 1
            if row["Color 1"] not in sock_colors_dict.keys(): #if new sock color
                sock_colors_dict[row["Color 1"]] = 1
            else: #if we've seen the sock type before
                sock_colors_dict[row["Color 1"]] += 1 #add one to count of that sock type
            
            #color 2
            if row["Color 2"] not in sock_colors_dict.keys(): #if new sock color
                sock_colors_dict[row["Color 2"]] = 1
            elif row["Color 2"] != row["Color 1"]: #if we've seen the sock type before and the sock does not have the same color 1 and color 2
                sock_colors_dict[row["Color 2"]] += 1 #add one to count of that sock type

    print("Number of socks of each color: " + str(sock_colors_dict))
```
This returns the following: 

`Number of socks of each color: {'Pink': 41, 'Red': 39, 'Green': 50, 'Light blue': 33, 'Orange': 27, 'Purple': 37, 'Blue': 47, 'Yellow': 33, 'Beige': 15, 'White': 85, 'Black': 59, 'Brown': 11, 'Gray': 31, 'Colorful': 14}`.

# Reflections and notes on the code-writing process
As I have mentioned a couple times above, I walked into this lab with eyes only for nested dictionaries. The humble for loop, let alone lists, never crossed my mind. Over time, however, I realized that any elegant solution to the lab's questions would draw on everything that we had learned. With that, I went through our past modules and picked and chose the relevant components from each. Coding is all about using your metaphorical toolbox to its fullest, and that can only be done, I have learned, when you let yourself use the whole toolbox.

In addition to bouncing ideas off of my classmates while in class every day, I worked closely with my classmate Jack Komaroff and with Bulyn Panjamapirom, a member of the G-period section of Art of Data.
